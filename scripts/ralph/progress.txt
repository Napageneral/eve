# Ralph Progress Log for Eve
Started: 2026-01-08
Phase: go-etl-complete

## Codebase Patterns (keep updated)

### Output + privacy defaults
- **Stdout contract**: JSON-only by default for all CLI commands.
- **No message text by default**: message bodies should not appear in stdout/logs unless explicitly requested.

### Data + queries
- **Raw SQL only**: do not introduce ORMs for queries. Use `database/sql` with explicit SQL.
- **Idempotency**: every persisted artifact must have a unique idempotency key and use upserts (ON CONFLICT DO UPDATE/IGNORE).
- **Separate DBs**: eve.db (warehouse) and eve-queue.db (durable queue).

### Testing
- **Ralph harness**: `./scripts/ralph/verify.sh`
- **NO real Gemini calls in unit tests**: use `httptest` fake servers.
- **Synthetic fixtures for ETL tests**: create temp chat.db with known data, verify eve.db output.

### Go conventions
- **Single binary**: no Python runtime required.
- **Apple timestamps**: nanoseconds since 2001-01-01 (add 978307200 to convert to Unix).
- **Config precedence**: env vars > config file > defaults.

## Key Files

- `internal/etl/chatdb.go` — chat.db reader (already implemented)
- `internal/etl/watermark.go` — watermark tracking (already implemented)
- `internal/migrate/sql/warehouse/002_core_schema.sql` — target schema
- `cmd/eve/main.go` — CLI entry point

## Previous Phase Summary (EVGO-001 to EVGO-010)

All 10 stories passed:
- Go module + CLI skeleton
- Config loading with env overrides
- Embedded SQL migrations
- Durable queue (enqueue/lease/ack/fail)
- Gemini HTTP client with retries
- Compute engine with worker pools
- Analysis job handler
- Embeddings pipeline with batching
- ETL bootstrap (message count + watermark only)

**Gap**: `eve sync` currently only counts messages and updates watermark. It does NOT copy data.

---

## Story Progress (append after each story)

### EVGO-011 (2026-01-08)
**Status:** ✅ PASSED
**What changed:**
- Implemented SyncHandles() to copy handles from chat.db to eve.db
- Reads all handles with ROWID and identifier from chat.db handle table
- Inserts into contacts table using handle ROWID as contact_id (preserves FK references)
- Inserts into contact_identifiers with type detection (email if contains @, else phone)
- Idempotent via check-before-insert pattern (no UNIQUE constraint on contact_identifiers yet)
**Files changed:**
- internal/etl/handles.go (new)
- internal/etl/handles_test.go (new)
**Learnings:**
- Handle ROWID → contact_id mapping is critical for FK consistency with messages later
- contact_identifiers schema lacks UNIQUE constraint, so used check-then-insert for idempotency
- Simple @ detection works for email vs phone classification
- Test helper naming collision: renamed to createTestWarehouseDBWithContacts() to avoid conflict with watermark_test.go

---
### EVGO-012 (2026-01-08)
**Status:** ✅ PASSED
**What changed:**
- Implemented SyncChats() to copy chats from chat.db to eve.db
- Reads all chats with ROWID, chat_identifier, display_name, service_name, and style
- Inserts into chats table using chat ROWID as id (preserves FK references for messages)
- Maps style field to is_group boolean: style=43 is group chat, style=45 is 1:1 chat
- Idempotent via chat_identifier UNIQUE constraint with ON CONFLICT DO UPDATE
- Handles nullable display_name and service_name fields properly
**Files changed:**
- internal/etl/chats.go (new)
- internal/etl/chats_test.go (new)
**Learnings:**
- Chat ROWID → chats.id mapping is critical for FK consistency with messages table
- Style values 43 (group) and 45 (1:1) are the primary indicators of chat type in iMessage
- chat_identifier already has UNIQUE constraint in schema, so ON CONFLICT DO UPDATE works cleanly
- Nullable fields need sql.NullString handling when reading, but can store empty strings on write
- Test pattern consistent with handles_test.go: synthetic fixture creation + comprehensive edge case coverage

---

### EVGO-013 (2026-01-08)
**Status:** ✅ PASSED
**What changed:**
- Implemented SyncMessages() to copy messages from chat.db to eve.db
- Reads messages joined with chat_message_join to get chat_id mapping
- Converts Apple timestamps (nanoseconds since 2001-01-01) to Go time.Time
- Maps handle_id → sender_id (contact FK), preserving NULL for is_from_me messages
- Supports incremental sync via sinceRowID watermark parameter
- Idempotent via guid UNIQUE constraint with ON CONFLICT DO UPDATE
**Files changed:**
- internal/etl/messages.go (new)
- internal/etl/messages_test.go (new)
**Learnings:**
- Apple timestamp conversion: add duration to time.Date(2001,1,1,0,0,0,0,UTC)
- chat_message_join is critical: message table doesn't have direct chat_id field
- handle_id from chat.db maps to sender_id in eve.db (foreign key to contacts)
- is_from_me messages have handle_id=0 or NULL, so sender_id should be NULL
- guid UNIQUE constraint enables clean idempotency with ON CONFLICT DO UPDATE
- Incremental sync query: WHERE m.ROWID > ? filters efficiently for watermark
- Test fixtures need all three tables: message, chat_message_join, and junction data

---

### EVGO-014 (2026-01-08)
**Status:** ✅ PASSED
**What changed:**
- Implemented SyncAttachments() to copy attachments from chat.db to eve.db
- Reads attachments via message_attachment_join, joined with message table to get message guid
- Maps message guid → message id for foreign key reference using buildMessageMap()
- Converts Apple timestamps to Go time.Time for created_date field
- Stores filename, mime_type, size, uti, is_sticker fields
- Idempotent via guid UNIQUE constraint with ON CONFLICT DO UPDATE
- Handles nullable fields properly (filename, uti, mime_type, total_bytes)
**Files changed:**
- internal/etl/attachments.go (new)
- internal/etl/attachments_test.go (new)
**Learnings:**
- Attachments require 3-way join: attachment → message_attachment_join → message to get message guid
- Message guid → message id mapping is necessary because chat.db uses message ROWID but eve.db uses auto-generated id
- buildMessageMap() helper function makes the mapping efficient (single query, then lookup in memory)
- Sticker flag (is_sticker) is preserved from chat.db
- File paths are NOT copied, only metadata (per requirements)
- Attachment GUID provides clean idempotency via UNIQUE constraint
- Multiple attachments per message work naturally via message_id FK
- Test pattern: create both chat.db and eve.db fixtures, populate messages first, then sync attachments

---

### EVGO-015 (2026-01-08)
**Status:** ✅ PASSED
**What changed:**
- Implemented BuildConversations() to group messages into conversations based on time gaps
- Groups messages by chat_id and orders by timestamp
- Splits into new conversation when time gap between messages > 3 hours (10800 seconds)
- Creates conversation records with chat_id, initiator_id, start_time, end_time, message_count, gap_threshold
- Updates messages.conversation_id to reference their conversation
- Idempotent via clearConversationAssignments() which rebuilds from scratch each time
**Files changed:**
- internal/etl/conversations.go (new)
- internal/etl/conversations_test.go (new)
**Learnings:**
- 3-hour gap threshold matches original ChatStats logic for conversation grouping
- Initiator_id is set to the sender_id of the first message in each conversation
- NULL sender_id (is_from_me messages) results in NULL initiator_id for conversation
- Gap logic: if time since last message > threshold, start new conversation
- Edge case: gap exactly equal to 3 hours stays in same conversation (only > splits)
- Idempotency achieved by clearing all existing conversation assignments and rebuilding
- Test coverage includes: single conversation, multiple conversations with gaps, multiple chats, empty database, idempotency, boundary conditions, and NULL sender handling
- conversationGroup helper struct holds message IDs for batch updating conversation_id

---

