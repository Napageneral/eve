from datetime import datetime
from sqlalchemy import (
    Boolean, Column, Integer, String, Text, DateTime, ForeignKey, JSON,
    UniqueConstraint, func
)
from sqlalchemy.orm import relationship
from .base import Base  # Import from base.py

# ContextDefinition and ContextSelection models removed (2025-10-29)
# These are no longer used - Eve system manages context definitions directly
# Historical data migration: context_definitions and context_selections tables dropped

class PromptTemplate(Base):
    """
    Stores a prompt with placeholders, e.g.:
    'Analyze this data:\n{{conversation_analysis}}\nThen summarize.'
    """
    __tablename__ = "prompt_templates"

    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)  # e.g., "ConvoAll", "ReportSummary"
    version = Column(Integer, nullable=False, default=1)

    friendly_name = Column(String, nullable=True) # User-facing name
    description = Column(Text, nullable=True)
    prompt_text = Column(Text, nullable=False)    # Content of prompt.md
    question = Column(String, nullable=True)      # For "Ask Eve" type features
    
    # Stores mapping like: {"placeholder_in_prompt": "ExpectedContextDefinitionName_or_Type"}
    placeholder_mapping = Column(JSON, nullable=True) 
    category = Column(String, nullable=True)      # e.g., "conversation_analysis", "report_generation"
    
    # Stores the content of schema.json. Use Text or specific JSON type if your DB supports it well.
    response_schema_json = Column(JSON, nullable=True) 
    
    # Stores default LLM settings for this prompt, e.g., {"model_name": "xyz", "temperature": 0.7}
    default_llm_config_json = Column(JSON, nullable=True) 

    # Optional: For tracking if the prompt definition in DB matches the file system source
    # Can be hash of metadata.yaml + prompt.md + schema.json
    file_hash = Column(String, nullable=True) 

    created_at = Column(DateTime, default=func.now(), nullable=False)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

    # Relationship to Report model (if you want to see which reports used which template version)
    # reports = relationship("Report", back_populates="prompt_template") # Already exists

    __table_args__ = (UniqueConstraint('name', 'version', 'category', name='uq_prompt_template_name_version_category'),)

    def __repr__(self):
        return f"<PromptTemplate(id={self.id}, name='{self.name}', version={self.version}, category='{self.category}')>"

class Report(Base):
    """
    The final result after substituting context into a PromptTemplate and calling an LLM.
    """
    __tablename__ = "reports"

    id = Column(Integer, primary_key=True)
    chat_id = Column(Integer, ForeignKey("chats.id"), nullable=True)
    contact_id = Column(Integer, ForeignKey("contacts.id"), nullable=True)  # New field for contact-based reports
    title = Column(String, nullable=True)
    prompt_template_id = Column(Integer, ForeignKey("prompt_templates.id"), nullable=False)
    combined_prompt_text = Column(Text, nullable=False)  # The final prompt after placeholder substitution
    model_used = Column(String, nullable=True)
    response_text = Column(Text, nullable=True)
    cost = Column(String, nullable=True)  # or numeric cost/tokens
    context_selections = Column(JSON, nullable=True)  # Store mapping of placeholders to context selection IDs
    suggested_preview_description = Column(Text, nullable=True)  # Stored at creation time for publishing
    created_at = Column(DateTime, default=func.now(), nullable=False)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

    # Relationship to the PromptTemplate if desired
    prompt_template = relationship("PromptTemplate", backref="reports")

class ReportDisplay(Base):
    """
    Stores specialized UI code or post-processing for a given report, e.g., a React component.
    """
    __tablename__ = "report_displays"

    id = Column(Integer, primary_key=True)
    report_id = Column(Integer, ForeignKey("reports.id"), nullable=False)
    generated_code = Column(Text, nullable=False)  # Stores the React component code
    model_used = Column(String, nullable=True)    # e.g., "gpt-4" if generated by LLM
    cost = Column(String, nullable=True)  # Store the cost of generating the display
    created_at = Column(DateTime, default=func.now(), nullable=False)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

    report = relationship("Report", backref="displays")

class PublishedReport(Base):
    """
    Provides a public slug/URL and link preview for a shared report.
    """
    __tablename__ = "published_reports"

    id = Column(Integer, primary_key=True)
    report_id = Column(Integer, ForeignKey("reports.id"), nullable=False)
    report_display_id = Column(Integer, ForeignKey("report_displays.id"), nullable=True)  # Optional link to display
    slug = Column(String, unique=True, nullable=False)  # e.g., "wrapped-abc123"
    preview_image_url = Column(String, nullable=True)
    preview_description = Column(Text, nullable=True)
    is_password_protected = Column(Boolean, default=False, nullable=False)
    password_hash = Column(String, nullable=True)  # Store hashed password if protected
    password_hint = Column(String, nullable=True)  # Optional hint for password
    server_slug = Column(String, nullable=True)  # Store the server's slug when published
    server_display_id = Column(Integer, nullable=True)  # Store the server's display ID when published
    server_published_at = Column(DateTime, nullable=True)  # When it was published to the server
    created_at = Column(DateTime, default=func.now(), nullable=False)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

    report = relationship("Report", backref="published_reports")
    report_display = relationship("ReportDisplay", backref="published_reports")